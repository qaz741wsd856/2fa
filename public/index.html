<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://cdn.jsdelivr.net 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' blob: data:; connect-src 'self'; media-src 'self' blob:;">
    <title>2FA Authenticator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg: #f5f5f5;
            --card-bg: #ffffff;
            --text: #333333;
            --text-secondary: #666666;
            --border: #e0e0e0;
            --primary: #2563eb;
            --primary-hover: #1d4ed8;
            --danger: #dc2626;
            --danger-hover: #b91c1c;
            --success: #16a34a;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #1a1a1a;
                --card-bg: #2d2d2d;
                --text: #e5e5e5;
                --text-secondary: #a0a0a0;
                --border: #404040;
                --primary: #3b82f6;
                --primary-hover: #2563eb;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 480px;
            margin: 0 auto;
        }

        h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 24px;
            text-align: center;
        }

        .card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
            border: 1px solid var(--border);
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 6px;
            color: var(--text-secondary);
        }

        input[type="text"],
        input[type="password"] {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--bg);
            color: var(--text);
            outline: none;
            transition: border-color 0.2s;
        }

        input:focus {
            border-color: var(--primary);
        }

        button {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
            width: 100%;
        }

        .btn-primary:hover {
            background: var(--primary-hover);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
            padding: 8px 12px;
            font-size: 12px;
        }

        .btn-danger:hover {
            background: var(--danger-hover);
        }

        .btn-secondary {
            background: var(--border);
            color: var(--text);
        }

        .btn-secondary:hover {
            background: var(--text-secondary);
            color: white;
        }

        .token-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 12px;
            margin-bottom: 12px;
        }

        .token-info {
            flex: 1;
            cursor: pointer;
        }

        .token-name {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .token-code {
            font-size: 32px;
            font-weight: 600;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            letter-spacing: 4px;
        }

        .token-actions {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .progress-ring {
            width: 36px;
            height: 36px;
        }

        .progress-ring circle {
            fill: none;
            stroke-width: 3;
        }

        .progress-ring .bg {
            stroke: var(--border);
        }

        .progress-ring .progress {
            stroke: var(--primary);
            stroke-linecap: round;
            transform: rotate(-90deg);
            transform-origin: center;
            transition: stroke-dashoffset 1s linear;
        }

        .progress-text {
            font-size: 11px;
            fill: var(--text-secondary);
            text-anchor: middle;
            dominant-baseline: middle;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        .hidden {
            display: none !important;
        }

        .copied {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--success);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .copied.show {
            opacity: 1;
        }

        .header-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .header-actions h1 {
            margin-bottom: 0;
        }

        .btn-icon {
            background: none;
            padding: 8px;
            color: var(--text-secondary);
        }

        .btn-icon:hover {
            color: var(--text);
        }

        .error {
            color: var(--danger);
            font-size: 14px;
            margin-top: 8px;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 100;
        }

        .modal {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 24px;
            width: 100%;
            max-width: 400px;
        }

        .modal h2 {
            font-size: 18px;
            margin-bottom: 16px;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        .modal-actions button {
            flex: 1;
        }

        .input-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }

        .input-tabs button {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .input-tabs button.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        #qr-camera-container {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 12px;
        }

        #qr-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #qr-canvas {
            display: none;
        }

        .scan-guide {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60%;
            height: 60%;
            border: 2px solid var(--primary);
            border-radius: 8px;
            pointer-events: none;
        }

        #qr-camera-status {
            text-align: center;
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s;
            color: var(--text-secondary);
        }

        .upload-zone:hover,
        .upload-zone.dragover {
            border-color: var(--primary);
        }

        #qr-preview {
            max-width: 100%;
            max-height: 200px;
            border-radius: 8px;
            margin-top: 12px;
            display: none;
        }

        #qr-preview.show {
            display: block;
        }

        .btn-scan {
            width: 100%;
            margin-top: 12px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js" integrity="sha384-OLBgp1GsljhM2TJ+sbHjaiH9txEUvgdDTAzHv2P24donTt6/529l+9Ua0vFImLlb" crossorigin="anonymous"></script>
</head>
<body>
    <div class="container">
        <!-- Unlock Screen -->
        <div id="unlock-screen">
            <h1>2FA Authenticator</h1>
            <div class="card">
                <div id="setup-password" class="hidden">
                    <div class="form-group">
                        <label for="new-password">设置主密码</label>
                        <input type="password" id="new-password" placeholder="输入密码">
                    </div>
                    <div class="form-group">
                        <label for="confirm-password">确认密码</label>
                        <input type="password" id="confirm-password" placeholder="再次输入密码">
                    </div>
                    <div id="setup-error" class="error hidden"></div>
                    <div class="form-group">
                        <button class="btn-primary" onclick="setupPassword()">设置密码</button>
                    </div>
                    <div style="text-align: center; margin-top: 12px;">
                        <a href="javascript:showLoginForm()" style="color: var(--primary); font-size: 14px;">已有账户? 直接登录</a>
                    </div>
                </div>
                <div id="enter-password">
                    <div class="form-group">
                        <label for="password">主密码</label>
                        <input type="password" id="password" placeholder="输入密码" onkeypress="if(event.key==='Enter')unlock()">
                    </div>
                    <div id="unlock-error" class="error hidden"></div>
                    <div class="form-group">
                        <button class="btn-primary" onclick="unlock()">解锁</button>
                    </div>
                    <div style="text-align: center; margin-top: 12px;">
                        <a href="javascript:showSetupForm()" style="color: var(--primary); font-size: 14px;">首次使用? 创建账户</a>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main App -->
        <div id="main-app" class="hidden">
            <div class="header-actions">
                <button class="btn-icon" onclick="logout()" title="退出">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                        <polyline points="16 17 21 12 16 7"></polyline>
                        <line x1="21" y1="12" x2="9" y2="12"></line>
                    </svg>
                </button>
                <h1>2FA Authenticator</h1>
                <button class="btn-icon" onclick="showAddModal()" title="添加密钥">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </button>
            </div>
            <div id="token-list"></div>
            <div id="empty-state" class="empty-state hidden">
                <p>还没有添加密钥</p>
                <p style="margin-top: 8px; font-size: 14px;">点击 + 添加你的第一个 2FA 密钥</p>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn-secondary" onclick="importKeys()" style="margin-right: 8px;">导入</button>
                <button class="btn-secondary" onclick="exportKeys()">导出</button>
            </div>
        </div>

        <!-- Add Modal -->
        <div id="add-modal" class="modal-overlay hidden">
            <div class="modal">
                <h2>添加新密钥</h2>
                <div class="input-tabs">
                    <button class="active" onclick="switchInputTab('manual')">手动输入</button>
                    <button onclick="switchInputTab('scan')">扫描</button>
                    <button onclick="switchInputTab('upload')">上传</button>
                </div>
                <div class="tab-content active" id="tab-manual">
                    <div class="form-group">
                        <label for="key-name">名称</label>
                        <input type="text" id="key-name" placeholder="例如: GitHub">
                    </div>
                    <div class="form-group">
                        <label for="key-secret">密钥</label>
                        <input type="text" id="key-secret" placeholder="Base32 密钥">
                    </div>
                </div>
                <div class="tab-content" id="tab-scan">
                    <div id="qr-camera-container">
                        <video id="qr-video" playsinline></video>
                        <canvas id="qr-canvas"></canvas>
                        <div class="scan-guide"></div>
                    </div>
                    <div id="qr-camera-status">点击下方按钮启动摄像头</div>
                    <button class="btn-primary btn-scan" onclick="startQrScanner()">启动摄像头</button>
                </div>
                <div class="tab-content" id="tab-upload">
                    <div class="upload-zone" id="upload-zone">
                        <p>点击选择、拖拽或粘贴图片</p>
                        <p style="font-size: 12px; margin-top: 8px;">支持 PNG / JPG / WEBP</p>
                    </div>
                    <input type="file" id="qr-upload" accept="image/png,image/jpeg,image/webp" hidden>
                    <img id="qr-preview">
                </div>
                <div id="add-error" class="error hidden"></div>
                <div class="modal-actions" id="modal-actions-manual">
                    <button class="btn-secondary" onclick="hideAddModal()">取消</button>
                    <button class="btn-primary" onclick="addKey()">添加</button>
                </div>
                <div class="modal-actions hidden" id="modal-actions-other">
                    <button class="btn-secondary" onclick="hideAddModal()" style="width: 100%;">取消</button>
                </div>
            </div>
        </div>

        <!-- Copied Toast -->
        <div id="copied-toast" class="copied">已复制</div>
    </div>

    <script>
        // State
        let masterKey = null;
        let keys = [];
        let updateInterval = null;
        let currentKeyHash = null;
        let currentSalt = null;

        // QR Scanner State
        let qrStream = null;
        let qrScanInterval = null;

        // ============ Utils ============
        function generateId() {
            if (typeof crypto.randomUUID === 'function') {
                return crypto.randomUUID();
            }
            return `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
        }

        // ============ Session ============
        const SESSION_KEY = '2fa_session';

        async function exportKey(key) {
            const exported = await crypto.subtle.exportKey('raw', key);
            return btoa(String.fromCharCode(...new Uint8Array(exported)));
        }

        async function importKey(keyStr) {
            const keyData = Uint8Array.from(atob(keyStr), c => c.charCodeAt(0));
            return crypto.subtle.importKey(
                'raw', keyData, { name: 'AES-GCM', length: 256 }, true, ['encrypt', 'decrypt']
            );
        }

        function saveSession(keyStr, keyHash, salt) {
            sessionStorage.setItem(SESSION_KEY, JSON.stringify({ keyStr, keyHash, salt }));
        }

        function loadSession() {
            const data = sessionStorage.getItem(SESSION_KEY);
            return data ? JSON.parse(data) : null;
        }

        function clearSession() {
            sessionStorage.removeItem(SESSION_KEY);
        }

        // ============ PBKDF2 Iterations ============
        const PBKDF2_ITERATIONS = {
            V1_KEY_HASH: 50000,
            V1_DERIVE_KEY: 100000,
            V2: 600000
        };
        const CURRENT_VERSION = 2;

        // ============ API Client ============
        async function apiGet(keyHash) {
            const response = await fetch(`/api/data?key=${encodeURIComponent(keyHash)}`);
            if (!response.ok) throw new Error('API Error');
            return response.json();
        }

        async function apiSave(keyHash, encryptedData, salt, version = CURRENT_VERSION) {
            const response = await fetch('/api/data', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ key: keyHash, data: encryptedData, salt: salt, version: version }),
            });
            if (!response.ok) throw new Error('API Error');
            return response.json();
        }

        async function apiDelete(keyHash) {
            const response = await fetch(`/api/data?key=${encodeURIComponent(keyHash)}`, {
                method: 'DELETE',
            });
            if (!response.ok) throw new Error('API Error');
            return response.json();
        }

        // ============ Key Hash ============
        async function deriveKeyHash(password, iterations = PBKDF2_ITERATIONS.V2) {
            const enc = new TextEncoder();
            const fixedSalt = enc.encode('2fa-sync-v1-key-hash');

            const keyMaterial = await crypto.subtle.importKey(
                'raw', enc.encode(password), 'PBKDF2', false, ['deriveBits']
            );

            const bits = await crypto.subtle.deriveBits(
                { name: 'PBKDF2', salt: fixedSalt, iterations: iterations, hash: 'SHA-256' },
                keyMaterial, 256
            );

            return Array.from(new Uint8Array(bits))
                .map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // ============ Salt ============
        function generateSalt() {
            const salt = crypto.getRandomValues(new Uint8Array(16));
            return btoa(String.fromCharCode(...salt));
        }

        function decodeSalt(saltStr) {
            return Uint8Array.from(atob(saltStr), c => c.charCodeAt(0));
        }

        // ============ Base32 ============
        const BASE32_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';

        function base32Decode(str) {
            str = str.toUpperCase().replace(/[^A-Z2-7]/g, '');
            const bits = [];
            for (const char of str) {
                const val = BASE32_CHARS.indexOf(char);
                if (val === -1) continue;
                bits.push(...val.toString(2).padStart(5, '0').split('').map(Number));
            }
            const bytes = [];
            for (let i = 0; i + 8 <= bits.length; i += 8) {
                bytes.push(parseInt(bits.slice(i, i + 8).join(''), 2));
            }
            return new Uint8Array(bytes);
        }

        // ============ OTPAuth URI ============
        function parseOtpauthUri(uri) {
            if (!uri || !uri.startsWith('otpauth://totp/')) {
                return null;
            }
            try {
                const url = new URL(uri);
                const secret = url.searchParams.get('secret');
                if (!secret) return null;

                const label = decodeURIComponent(url.pathname.slice(6));
                const issuer = url.searchParams.get('issuer');
                let name = issuer || (label.includes(':') ? label.split(':')[0] : label) || '未命名';

                return { name: name.trim(), secret: secret.replace(/\s+/g, '').toUpperCase() };
            } catch {
                return null;
            }
        }

        // ============ TOTP ============
        async function generateTOTP(secret, time = Date.now()) {
            const counter = Math.floor(time / 30000);
            const counterBytes = new Uint8Array(8);
            let temp = counter;
            for (let i = 7; i >= 0; i--) {
                counterBytes[i] = temp & 0xff;
                temp = Math.floor(temp / 256);
            }

            const keyData = base32Decode(secret);
            const key = await crypto.subtle.importKey(
                'raw',
                keyData,
                { name: 'HMAC', hash: 'SHA-1' },
                false,
                ['sign']
            );

            const signature = await crypto.subtle.sign('HMAC', key, counterBytes);
            const hash = new Uint8Array(signature);

            const offset = hash[hash.length - 1] & 0x0f;
            const binary =
                ((hash[offset] & 0x7f) << 24) |
                ((hash[offset + 1] & 0xff) << 16) |
                ((hash[offset + 2] & 0xff) << 8) |
                (hash[offset + 3] & 0xff);

            return (binary % 1000000).toString().padStart(6, '0');
        }

        // ============ Encryption ============
        async function deriveKey(password, salt, iterations = PBKDF2_ITERATIONS.V2) {
            const enc = new TextEncoder();
            const keyMaterial = await crypto.subtle.importKey(
                'raw',
                enc.encode(password),
                'PBKDF2',
                false,
                ['deriveKey']
            );
            return crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: iterations,
                    hash: 'SHA-256'
                },
                keyMaterial,
                { name: 'AES-GCM', length: 256 },
                true,
                ['encrypt', 'decrypt']
            );
        }

        async function encrypt(data, key) {
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const enc = new TextEncoder();
            const encrypted = await crypto.subtle.encrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                enc.encode(JSON.stringify(data))
            );
            const combined = new Uint8Array(iv.length + encrypted.byteLength);
            combined.set(iv);
            combined.set(new Uint8Array(encrypted), iv.length);
            return btoa(String.fromCharCode(...combined));
        }

        async function decrypt(encryptedData, key) {
            const combined = Uint8Array.from(atob(encryptedData), c => c.charCodeAt(0));
            const iv = combined.slice(0, 12);
            const data = combined.slice(12);
            const decrypted = await crypto.subtle.decrypt(
                { name: 'AES-GCM', iv: iv },
                key,
                data
            );
            return JSON.parse(new TextDecoder().decode(decrypted));
        }

        // ============ Cloud Storage ============
        async function saveKeys() {
            if (!masterKey || !currentKeyHash) return;
            const encrypted = await encrypt(keys, masterKey);
            await apiSave(currentKeyHash, encrypted, currentSalt);
        }

        async function loadKeysFromCloud(keyHash) {
            const result = await apiGet(keyHash);
            if (!result.exists) {
                return { exists: false, data: null, salt: null };
            }

            let stored;
            try {
                stored = JSON.parse(result.data);
            } catch (e) {
                console.error('Invalid server response format:', e);
                throw new Error('服务器响应格式错误');
            }

            if (!stored || typeof stored.encryptedData !== 'string' || typeof stored.salt !== 'string') {
                console.error('Missing required fields in server response');
                throw new Error('服务器响应数据不完整');
            }

            return { exists: true, data: stored.encryptedData, salt: stored.salt };
        }

        // ============ UI ============
        function showError(elementId, message) {
            const el = document.getElementById(elementId);
            el.textContent = message;
            el.classList.remove('hidden');
        }

        function hideError(elementId) {
            document.getElementById(elementId).classList.add('hidden');
        }

        function showSetupForm() {
            document.getElementById('setup-password').classList.remove('hidden');
            document.getElementById('enter-password').classList.add('hidden');
        }

        function showLoginForm() {
            document.getElementById('setup-password').classList.add('hidden');
            document.getElementById('enter-password').classList.remove('hidden');
        }

        function validatePassword(password) {
            if (password.length < 8) {
                return { valid: false, error: '密码至少需要8个字符' };
            }
            if (!/[a-zA-Z]/.test(password)) {
                return { valid: false, error: '密码需要包含至少一个字母' };
            }
            if (!/[0-9]/.test(password)) {
                return { valid: false, error: '密码需要包含至少一个数字' };
            }
            return { valid: true };
        }

        async function setupPassword() {
            const password = document.getElementById('new-password').value;
            const confirm = document.getElementById('confirm-password').value;

            hideError('setup-error');

            const validation = validatePassword(password);
            if (!validation.valid) {
                showError('setup-error', validation.error);
                return;
            }

            if (password !== confirm) {
                showError('setup-error', '两次密码不一致');
                return;
            }

            try {
                const oldKeyHash = await deriveKeyHash(password, PBKDF2_ITERATIONS.V1_KEY_HASH);
                const oldCloudData = await loadKeysFromCloud(oldKeyHash);
                if (oldCloudData.exists) {
                    showError('setup-error', '此密码已被使用，请直接登录');
                    return;
                }

                currentKeyHash = await deriveKeyHash(password, PBKDF2_ITERATIONS.V2);

                const cloudData = await loadKeysFromCloud(currentKeyHash);
                if (cloudData.exists) {
                    showError('setup-error', '此密码已被使用，请换一个密码或直接登录');
                    return;
                }

                currentSalt = generateSalt();
                masterKey = await deriveKey(password, decodeSalt(currentSalt), PBKDF2_ITERATIONS.V2);
                keys = [];
                await saveKeys();

                saveSession(await exportKey(masterKey), currentKeyHash, currentSalt);
                showMainApp();
            } catch (error) {
                showError('setup-error', '网络错误，请重试');
            }
        }

        async function unlock() {
            const password = document.getElementById('password').value;
            hideError('unlock-error');

            if (!password) {
                showError('unlock-error', '请输入密码');
                return;
            }

            try {
                const oldKeyHash = await deriveKeyHash(password, PBKDF2_ITERATIONS.V1_KEY_HASH);
                const oldCloudData = await loadKeysFromCloud(oldKeyHash);

                if (oldCloudData.exists) {
                    const migrateResult = await migrateFromV1(password, oldKeyHash, oldCloudData);
                    if (!migrateResult.success) {
                        showError('unlock-error', migrateResult.error);
                        return;
                    }
                    saveSession(await exportKey(masterKey), currentKeyHash, currentSalt);
                    showMainApp();
                    return;
                }

                currentKeyHash = await deriveKeyHash(password, PBKDF2_ITERATIONS.V2);
                const cloudData = await loadKeysFromCloud(currentKeyHash);

                if (!cloudData.exists) {
                    showError('unlock-error', '密码错误或账户不存在');
                    return;
                }

                currentSalt = cloudData.salt;
                masterKey = await deriveKey(password, decodeSalt(currentSalt), PBKDF2_ITERATIONS.V2);

                try {
                    keys = await decrypt(cloudData.data, masterKey);
                } catch {
                    showError('unlock-error', '密码错误');
                    masterKey = null;
                    currentKeyHash = null;
                    currentSalt = null;
                    return;
                }

                saveSession(await exportKey(masterKey), currentKeyHash, currentSalt);
                showMainApp();
            } catch (error) {
                showError('unlock-error', '网络错误，请重试');
            }
        }

        async function migrateFromV1(password, oldKeyHash, oldCloudData) {
            try {
                const oldKey = await deriveKey(password, decodeSalt(oldCloudData.salt), PBKDF2_ITERATIONS.V1_DERIVE_KEY);
                try {
                    keys = await decrypt(oldCloudData.data, oldKey);
                } catch {
                    return { success: false, error: '密码错误' };
                }

                currentKeyHash = await deriveKeyHash(password, PBKDF2_ITERATIONS.V2);
                currentSalt = generateSalt();
                masterKey = await deriveKey(password, decodeSalt(currentSalt), PBKDF2_ITERATIONS.V2);

                const encrypted = await encrypt(keys, masterKey);
                await apiSave(currentKeyHash, encrypted, currentSalt, CURRENT_VERSION);

                await apiDelete(oldKeyHash);

                return { success: true };
            } catch (error) {
                return { success: false, error: '迁移失败，请重试' };
            }
        }

        function showMainApp() {
            document.getElementById('unlock-screen').classList.add('hidden');
            document.getElementById('main-app').classList.remove('hidden');
            renderKeys();
            startUpdateInterval();
        }

        function logout() {
            if (updateInterval) clearInterval(updateInterval);
            clearSession();
            masterKey = null;
            keys = [];
            currentKeyHash = null;
            currentSalt = null;
            document.getElementById('main-app').classList.add('hidden');
            document.getElementById('unlock-screen').classList.remove('hidden');
            document.getElementById('password').value = '';
            showLoginForm();
        }

        function showAddModal() {
            document.getElementById('key-name').value = '';
            document.getElementById('key-secret').value = '';
            hideError('add-error');
            document.getElementById('add-modal').classList.remove('hidden');
        }

        function hideAddModal() {
            stopQrScanner();
            document.getElementById('qr-preview').classList.remove('show');
            document.getElementById('add-modal').classList.add('hidden');
        }

        // ============ Tab Switching ============
        function switchInputTab(tab) {
            stopQrScanner();
            clearUploadPreview();

            const tabs = document.querySelectorAll('.input-tabs button');
            const contents = document.querySelectorAll('.tab-content');
            tabs.forEach(t => t.classList.remove('active'));
            contents.forEach(c => c.classList.remove('active'));

            const activeTab = document.querySelector(`.input-tabs button[onclick*="${tab}"]`);
            const activeContent = document.getElementById(`tab-${tab}`);
            if (activeTab) activeTab.classList.add('active');
            if (activeContent) activeContent.classList.add('active');

            const actionsManual = document.getElementById('modal-actions-manual');
            const actionsOther = document.getElementById('modal-actions-other');
            if (tab === 'manual') {
                actionsManual.classList.remove('hidden');
                actionsOther.classList.add('hidden');
            } else {
                actionsManual.classList.add('hidden');
                actionsOther.classList.remove('hidden');
            }
        }

        function clearUploadPreview() {
            const preview = document.getElementById('qr-preview');
            if (preview.src && preview.src.startsWith('blob:')) {
                URL.revokeObjectURL(preview.src);
            }
            preview.classList.remove('show');
            preview.src = '';
        }

        // ============ QR Scanner ============
        async function startQrScanner() {
            const video = document.getElementById('qr-video');
            const canvas = document.getElementById('qr-canvas');
            const status = document.getElementById('qr-camera-status');
            hideError('add-error');

            if (typeof jsQR === 'undefined') {
                showError('add-error', '二维码识别库加载失败, 请刷新页面重试');
                return;
            }

            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showError('add-error', '浏览器不支持摄像头访问');
                return;
            }

            status.textContent = '正在请求摄像头权限...';

            try {
                qrStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                video.srcObject = qrStream;
                await video.play();

                canvas.width = video.videoWidth || 640;
                canvas.height = video.videoHeight || 480;

                status.textContent = '扫描中...';
                qrScanInterval = setInterval(() => scanQrFrame(video, canvas), 200);
            } catch (err) {
                stopQrScanner();
                if (err.name === 'NotAllowedError') {
                    showError('add-error', '摄像头权限被拒绝, 请在浏览器设置中允许');
                } else if (err.name === 'NotFoundError') {
                    showError('add-error', '未检测到摄像头设备');
                } else {
                    console.error('Camera error:', err);
                    showError('add-error', '摄像头启动失败, 请检查设备和权限设置');
                }
                status.textContent = '摄像头启动失败';
            }
        }

        function stopQrScanner() {
            if (qrScanInterval) {
                clearInterval(qrScanInterval);
                qrScanInterval = null;
            }
            if (qrStream) {
                qrStream.getTracks().forEach(track => track.stop());
                qrStream = null;
            }
            const video = document.getElementById('qr-video');
            if (video) video.srcObject = null;
            const status = document.getElementById('qr-camera-status');
            if (status) status.textContent = '点击下方按钮启动摄像头';
        }

        function scanQrFrame(video, canvas) {
            if (!qrStream) return;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const code = jsQR(imageData.data, imageData.width, imageData.height);

            if (code && code.data) {
                stopQrScanner();
                processQrCode(code.data);
            }
        }

        function processQrCode(data) {
            const parsed = parseOtpauthUri(data);
            if (!parsed) {
                showError('add-error', '仅支持 otpauth://totp/ 格式的二维码');
                return;
            }
            document.getElementById('key-name').value = parsed.name;
            document.getElementById('key-secret').value = parsed.secret;
            switchInputTab('manual');
        }

        // ============ Image Upload ============
        function setupUploadZone() {
            const zone = document.getElementById('upload-zone');
            const input = document.getElementById('qr-upload');

            zone.addEventListener('click', () => input.click());

            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('dragover');
            });

            zone.addEventListener('dragleave', () => {
                zone.classList.remove('dragover');
            });

            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file) handleQrUpload(file);
            });

            input.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) handleQrUpload(file);
                input.value = '';
            });

            document.addEventListener('paste', (e) => {
                const modal = document.getElementById('add-modal');
                const uploadTab = document.getElementById('tab-upload');
                if (modal.classList.contains('hidden') || !uploadTab.classList.contains('active')) {
                    return;
                }
                const items = e.clipboardData?.items;
                if (!items) return;
                for (const item of items) {
                    if (item.type.startsWith('image/')) {
                        const file = item.getAsFile();
                        if (file) handleQrUpload(file);
                        break;
                    }
                }
            });
        }

        function handleQrUpload(file) {
            hideError('add-error');
            const preview = document.getElementById('qr-preview');

            if (typeof jsQR === 'undefined') {
                showError('add-error', '二维码识别库加载失败, 请刷新页面重试');
                return;
            }

            if (!file.type.match(/^image\/(png|jpeg|webp)$/)) {
                showError('add-error', '仅支持 PNG/JPG/WEBP 格式图片');
                return;
            }

            if (file.size > 5 * 1024 * 1024) {
                showError('add-error', '图片文件过大, 请选择小于 5MB 的图片');
                return;
            }

            clearUploadPreview();

            const previewUrl = URL.createObjectURL(file);
            preview.src = previewUrl;
            preview.classList.add('show');

            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const code = jsQR(imageData.data, imageData.width, imageData.height);

                if (code && code.data) {
                    processQrCode(code.data);
                } else {
                    showError('add-error', '图片中未识别到二维码');
                }
                URL.revokeObjectURL(img.src);
            };

            img.onerror = () => {
                showError('add-error', '图片加载失败');
                URL.revokeObjectURL(img.src);
            };

            img.src = URL.createObjectURL(file);
        }

        async function addKey() {
            const name = document.getElementById('key-name').value.trim();
            const secret = document.getElementById('key-secret').value.trim();

            hideError('add-error');

            if (!name) {
                showError('add-error', '请输入名称');
                return;
            }

            if (!secret) {
                showError('add-error', '请输入密钥');
                return;
            }

            if (keys.some(k => k.name === name)) {
                showError('add-error', '该名称已存在');
                return;
            }

            try {
                await generateTOTP(secret);
            } catch {
                showError('add-error', '密钥格式无效');
                return;
            }

            keys.push({ id: generateId(), name, secret });
            await saveKeys();
            hideAddModal();
            renderKeys();
        }

        async function deleteKey(id) {
            if (!confirm('确定删除这个密钥吗?')) return;
            keys = keys.filter(k => String(k.id) !== String(id));
            await saveKeys();
            renderKeys();
        }

        function showToast(message) {
            const toast = document.getElementById('copied-toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 1500);
        }

        async function copyCode(code) {
            try {
                await navigator.clipboard.writeText(code);
                showToast('已复制');
            } catch (err) {
                console.error('Clipboard API failed:', err);
                const textarea = document.createElement('textarea');
                textarea.value = code;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                textarea.style.pointerEvents = 'none';
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    showToast('已复制');
                } catch {
                    showToast('复制失败');
                }
                document.body.removeChild(textarea);
            }
        }

        function exportKeys() {
            if (keys.length === 0) {
                alert('没有可导出的密钥');
                return;
            }
            const now = new Date();
            const pad = n => n.toString().padStart(2, '0');
            const exportedAt = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())} ${pad(now.getHours())}:${pad(now.getMinutes())}:${pad(now.getSeconds())}`;
            const exportData = {
                version: 1,
                exported_at: exportedAt,
                keys: keys.map(k => ({ name: k.name, secret: k.secret }))
            };
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `2fa-backup-${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        async function importKeys() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                if (file.size > 1024 * 1024) {
                    alert('文件过大, 请选择小于 1MB 的备份文件');
                    return;
                }
                try {
                    const text = await file.text();
                    const data = JSON.parse(text);
                    if (!data.keys || !Array.isArray(data.keys)) {
                        alert('无效的备份文件格式');
                        return;
                    }
                    const existingNames = new Set(keys.map(k => k.name));
                    let imported = 0;
                    let skipped = 0;
                    for (const item of data.keys) {
                        if (!item.name || !item.secret) continue;
                        if (existingNames.has(item.name)) {
                            skipped++;
                            continue;
                        }
                        try {
                            await generateTOTP(item.secret);
                            keys.push({ id: generateId(), name: item.name, secret: item.secret });
                            existingNames.add(item.name);
                            imported++;
                        } catch {
                            skipped++;
                        }
                    }
                    if (imported > 0) {
                        await saveKeys();
                        await renderKeys();
                    }
                    alert(`导入完成: ${imported} 个成功, ${skipped} 个跳过`);
                } catch {
                    alert('导入失败: 文件格式错误');
                }
            };
            input.click();
        }

        async function renderKeys() {
            const list = document.getElementById('token-list');
            const empty = document.getElementById('empty-state');

            if (keys.length === 0) {
                list.innerHTML = '';
                empty.classList.remove('hidden');
                return;
            }

            empty.classList.add('hidden');

            const now = Date.now();
            const remaining = 30 - Math.floor((now / 1000) % 30);
            const progress = (remaining / 30) * 100;
            const circumference = 2 * Math.PI * 15;
            const offset = circumference * (1 - progress / 100);

            let html = '';
            for (const key of keys) {
                const code = await generateTOTP(key.secret);
                html += `
                    <div class="token-item" data-key-id="${escapeHtml(String(key.id))}">
                        <div class="token-info">
                            <div class="token-name">${escapeHtml(key.name)}</div>
                            <div class="token-code">${escapeHtml(code)}</div>
                        </div>
                        <div class="token-actions">
                            <svg class="progress-ring" viewBox="0 0 36 36">
                                <circle class="bg" cx="18" cy="18" r="15"></circle>
                                <circle class="progress" cx="18" cy="18" r="15"
                                    stroke-dasharray="${circumference}"
                                    stroke-dashoffset="${offset}"></circle>
                                <text class="progress-text" x="18" y="18">${remaining}</text>
                            </svg>
                            <button class="btn-danger" data-action="delete">删除</button>
                        </div>
                    </div>
                `;
            }
            list.innerHTML = html;
        }

        function setupTokenListEvents() {
            const list = document.getElementById('token-list');
            list.addEventListener('click', (e) => {
                const tokenItem = e.target.closest('.token-item');
                if (!tokenItem) return;

                const keyId = tokenItem.dataset.keyId;

                if (e.target.closest('.token-info')) {
                    const code = tokenItem.querySelector('.token-code').textContent;
                    copyCode(code);
                }

                if (e.target.closest('[data-action="delete"]')) {
                    deleteKey(keyId);
                }
            });
        }

        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function startUpdateInterval() {
            if (updateInterval) clearInterval(updateInterval);
            updateInterval = setInterval(renderKeys, 1000);
        }

        // ============ Init ============
        async function init() {
            setupUploadZone();
            setupTokenListEvents();
            const session = loadSession();

            if (session) {
                try {
                    masterKey = await importKey(session.keyStr);
                    currentKeyHash = session.keyHash;
                    currentSalt = session.salt;

                    const cloudData = await loadKeysFromCloud(currentKeyHash);
                    if (cloudData.exists) {
                        keys = await decrypt(cloudData.data, masterKey);
                        showMainApp();
                        return;
                    }
                } catch {
                    clearSession();
                }
            }

            document.getElementById('setup-password').classList.add('hidden');
            document.getElementById('enter-password').classList.remove('hidden');
        }

        // ============ Page Lifecycle ============
        window.addEventListener('beforeunload', () => {
            stopQrScanner();
        });

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                stopQrScanner();
            }
        });

        init();
    </script>
</body>
</html>
